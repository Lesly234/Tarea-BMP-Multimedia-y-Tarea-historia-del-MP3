# -*- coding: utf-8 -*-
"""P3_stego_avanzado.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OqkkvEXlyV1O1lbPTjj1cnReD2BMgnB5
"""

import struct
import random
import hashlib
import os
def leer_bmp(filepath):
    """Lee un archivo BMP y retorna sus componentes."""
    with open(filepath, 'rb') as f:
        data = f.read()
    offset = struct.unpack_from('<I', data, 10)[0]
    width  = struct.unpack_from('<i', data, 18)[0]
    height = struct.unpack_from('<i', data, 22)[0]
    row_size = (width * 3 + 3) & ~3
    header = bytearray(data[:offset])
    pixels = bytearray(data[offset:])
    return header, pixels, width, height, row_size
def guardar_bmp(filepath, header, pixels):
    """Guarda la imagen modificada."""
    with open(filepath, 'wb') as f:
        f.write(header)
        f.write(pixels)
def derivar_clave(password: str, longitud: int) -> bytes:
    """Genera una clave de longitud arbitraria usando SHA-256 en modo contador."""
    clave = b''
    contador = 0
    while len(clave) < longitud:
        bloque = hashlib.sha256(password.encode() + struct.pack('<I', contador)).digest()
        clave += bloque
        contador += 1
    return clave[:longitud]
def cifrar_xor(mensaje: bytes, password: str) -> bytes:
    """Aplica cifrado XOR entre el mensaje y la clave derivada."""
    clave = derivar_clave(password, len(mensaje))
    return bytes([m ^ k for m, k in zip(mensaje, clave)])
def descifrar_xor(cifrado: bytes, password: str) -> bytes:
    """Descifra el mensaje (XOR es simétrico, por lo que es la misma operación)."""
    return cifrar_xor(cifrado, password)
def semilla_de_password(password: str) -> int:
    """Convierte la contraseña en un entero para usar como semilla."""
    hash_bytes = hashlib.sha256(password.encode()).digest()
    return int.from_bytes(hash_bytes[:8], 'big')
def seleccionar_posiciones(total_bytes_imagen: int, n_bits: int, seed: int) -> list:
    """Selecciona n_bits índices únicos dentro del rango válido de la imagen."""
    rng = random.Random(seed)
    posiciones = rng.sample(range(total_bytes_imagen), n_bits)
    return sorted(posiciones) # Se ordena para escritura secuencial en disco
def embed_secure(src_path, dst_path, mensaje, password):
    header, pixels, width, height, row_size = leer_bmp(src_path)
    msg_bytes = mensaje.encode('utf-8')
    msg_cifrado = cifrar_xor(msg_bytes, password)
    datos = struct.pack('<I', len(msg_bytes)) + msg_cifrado
    bits = []
    for byte in datos:
        for i in range(7, -1, -1):
            bits.append((byte >> i) & 1)

    n_bits = len(bits)
    if n_bits > len(pixels):
        raise ValueError('Mensaje demasiado grande para esta imagen')
    seed = semilla_de_password(password)
    posiciones = seleccionar_posiciones(len(pixels), n_bits, seed)

    pixels_mod = bytearray(pixels)
    for pos, bit in zip(posiciones, bits):
        pixels_mod[pos] = (pixels_mod[pos] & 0xFE) | bit

    guardar_bmp(dst_path, header, pixels_mod)
    print(f"[OK] {len(msg_bytes)} bytes cifrados e incrustados en '{dst_path}'")
def extract_secure(stego_path, password):
    header, pixels, width, height, row_size = leer_bmp(stego_path)
    seed = semilla_de_password(password)


    pos_longitud = seleccionar_posiciones(len(pixels), 32, seed)
    len_bits = [pixels[p] & 1 for p in pos_longitud]


    len_bytes = bytearray()
    for i in range(0, 32, 8):
        byte_val = 0
        for bit in len_bits[i:i+8]:
            byte_val = (byte_val << 1) | bit
        len_bytes.append(byte_val)
    msg_len = struct.unpack('<I', len_bytes)[0]


    if msg_len == 0 or msg_len > len(pixels) // 8:
        raise Exception(f"Longitud inválida ({msg_len}). Probablemente la contraseña sea incorrecta.")


    total_bits = 32 + (msg_len * 8)
    todas_pos = seleccionar_posiciones(len(pixels), total_bits, seed)


    msg_bits = [pixels[p] & 1 for p in todas_pos[32:]]


    cifrado = bytearray()
    for i in range(0, len(msg_bits), 8):
        byte_val = 0
        for bit in msg_bits[i:i+8]:
            byte_val = (byte_val << 1) | bit
        cifrado.append(byte_val)


    return descifrar_xor(bytes(cifrado), password).decode('utf-8', errors='replace')
def chi_cuadrado_lsb(filepath):
    """Calcula la prueba chi-cuadrado para detectar anomalías en los LSB."""
    if not os.path.exists(filepath):
        print(f"  [!] Archivo no encontrado: {filepath}")
        return None
_, pixels, _, _, _ = leer_bmp(filepath)
    ceros = sum(1 for b in pixels if (b & 1) == 0)
    unos = len(pixels) - ceros
    esperado = len(pixels) / 2


    chi2 = ((ceros - esperado) ** 2 + (unos - esperado) ** 2) / esperado

    print(f"  LSBs=0: {ceros} | LSBs=1: {unos} | x² = {chi2:.4f}")
    if chi2 < 5.0: # Umbral estadístico común
        print("  -> Valor x² cercano a 0: Distribución uniforme (Indetectable).")
    else:
        print("  -> Valor x² alto: Distribución anómala (¡Sospechoso!).")
    return chi2
if __name__ == "__main__":
    print("=== PRÁCTICA 2: ESTEGANOGRAFÍA AVANZADA ===\n")

    img_orig = 'volcan.bmp'
    stego_seguro = 'stego_seguro.bmp'

    CLAVE = 'Telemática@2025'
    MENSAJE = 'Datos confidenciales de la red 10.0.1.0/24'

    if not os.path.exists(img_orig):
        print(f"Error: Asegúrate de tener una imagen llamada '{img_orig}' en la carpeta.")
    else:
        print("--- 1. PRUEBA DE OCULTAMIENTO Y CIFRADO ---")
        embed_secure(img_orig, stego_seguro, MENSAJE, CLAVE)

        print("\n--- 2. PRUEBA DE EXTRACCIÓN CON CLAVE CORRECTA ---")
        try:
            resultado = extract_secure(stego_seguro, CLAVE)
            print(f"Clave correcta -> \"{resultado}\"")
            assert resultado == MENSAJE, "El mensaje extraído no coincide."
        except Exception as e:
            print(f"Error al extraer: {e}")

        print("\n--- 3. PRUEBA DE EXTRACCIÓN CON CLAVE INCORRECTA ---")
        try:
            resultado_malo = extract_secure(stego_seguro, 'claveWrong')
            print(f"Clave incorrecta -> \"{resultado_malo[:30]}...\" (Basura esperada)")
        except Exception as e:
            print(f"Clave incorrecta -> Generó un error de longitud (comportamiento seguro): {e}")

        print("\n--- 4. ANÁLISIS ESTADÍSTICO (CHI-CUADRADO) ---")
        print("Imagen original:")
        chi_cuadrado_lsb(img_orig)
        stego_p1 = 'stego.bmp'
        print("\nStego LSB secuencial (Práctica 1):")
        chi_cuadrado_lsb(stego_p1)
        print("\nStego LSB aleatorio + XOR (Práctica 2):")
        chi_cuadrado_lsb(stego_seguro)